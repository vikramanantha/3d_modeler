<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Modeler - Vikram Anantha</title>
    <meta name="description" content="3D Modeler - A project to model 3D objects from photos">
    
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" type="image/png" href="../images/icon.png">
</head>
<body>
    <div class="container">
        <div id="header-placeholder"></div>
        <main>
            <div class="content-box" style="width: 100%; text-align: center; padding: 2rem;">
                <div class="title-with-icon">
                    <img src="icon.png" alt="3D Modeler Icon" class="title-icon">
                    <h1>3D Modeler</h1>
                </div>
                <p style="margin-bottom: 1.5rem; line-height: 1.8;">
                    Generating 3D models from all the photos that I have taken (I have a lot).
                    </p>
                <p style="margin-bottom: 1.5rem; line-height: 1.8;">
                    This uses <a href="https://github.com/facebookresearch/vggt" target="_blank" rel="noopener noreferrer" style="color: var(--color-main); font-weight: 600;">Facebook's VGGT</a> model to generate the 3D models <i>without</i> any camera parameters or positions. <br>
                    The only information given are the images shown below. <br>
                    Check out the <a href="https://github.com/vikramanantha/3d_modeler" target="_blank" rel="noopener noreferrer" style="color: var(--color-main); font-weight: 600;">project page</a>.
                </p>

                <!-- Model Selector and Location -->
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; flex-wrap: wrap; margin: 1rem 0;">
                    <div class="model-selector-container" style="margin-bottom: 0;">
                        <label for="model-select" class="model-selector-label">Select Model:</label>
                        <select id="model-select" class="model-selector">
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div id="location-display" class="location-display" style="font-size: 1rem; display: flex; align-items: center; line-height: 1.5;">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Viewer Options -->
                <div class="viewer-options">
                    <label class="toggle-switch">
                        <input type="checkbox" id="camera-toggle" checked>
                        <span class="toggle-slider"></span>
                        <span class="toggle-label"><i class="fas fa-video"></i> Show Cameras</span>
                    </label>
                </div>

                <!-- 3D Viewer -->
                <div id="viewer-container" class="viewer-container">
                    <div id="loading-indicator" class="loading-indicator">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>Loading model...</span>
                    </div>
                    <canvas id="three-canvas"></canvas>
                </div>

                <!-- Controls hint -->
                <div class="viewer-controls-hint">
                    <span><i class="fas fa-mouse"></i> Drag to rotate</span>
                    <span><i class="fas fa-search-plus"></i> Scroll to zoom</span>
                    <span><i class="fas fa-arrows-alt"></i> Right-click drag to pan</span>
                </div>

                <!-- Source Photos Gallery -->
                <div class="source-photos-section">
                    <h3 class="source-photos-title"><i class="fas fa-images"></i> Source Photos</h3>
                    <p class="source-photos-subtitle">These images were used to generate the 3D model</p>
                    <div id="photos-gallery" class="photos-gallery">
                        <p class="photos-loading">Loading photos...</p>
                    </div>
                </div>
            </div>
        </main>

        <div id="footer-placeholder"></div>
    </div>

    <script src="../header.js"></script>
    <script src="../footer.js"></script>
    
    <!-- Three.js and loaders -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Model registry - populated from JSON
        let MODELS = {};
        
        // Configuration
        const CONFIG = {
            github: {
                username: 'vikramanantha',
                repo: 'vikramanantha.github.io',
                branch: 'main'
            },
            paths: {
                modelsJson: '../images/3d/models.json',
                assets: 'images/3d/'
            }
        };
        
        // URL resolvers for different asset types
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        
        // For LFS files (GLB models) - use media.githubusercontent.com in production
        const getModelUrl = (relativePath) => {
            if (isLocalhost) {
                return `../${CONFIG.paths.assets}${relativePath}`;
            }
            const { username, repo, branch } = CONFIG.github;
            return `https://media.githubusercontent.com/media/${username}/${repo}/${branch}/${CONFIG.paths.assets}${relativePath}`;
        };
        
        // For regular files (photos) - use relative paths everywhere
        const getPhotoUrl = (relativePath) => {
            return `../${CONFIG.paths.assets}${relativePath}`;
        };

        let scene, camera, renderer, controls, currentModel;
        let cameraObjects = []; // Store references to camera frustum objects
        let mainPointCloud = null; // Store reference to the main point cloud
        let pointsObject = null; // Store the Points object for size control
        const canvas = document.getElementById('three-canvas');
        const container = document.getElementById('viewer-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const modelSelect = document.getElementById('model-select');
        const cameraToggle = document.getElementById('camera-toggle');
        const photosGallery = document.getElementById('photos-gallery');
        const locationDisplay = document.getElementById('location-display');

        // Load models config from JSON
        async function loadModelsConfig() {
            try {
                const response = await fetch(CONFIG.paths.modelsJson);
                const data = await response.json();
                
                // Build MODELS object and populate dropdown
                MODELS = {};
                modelSelect.innerHTML = '';
                
                data.models.forEach((model, index) => {
                    MODELS[model.id] = {
                        path: getModelUrl(model.file),
                        name: model.name,
                        photos: (model.photos || []).map(getPhotoUrl),
                        location: model.location || '',
                        mapsLink: model.maps_link || ''
                    };
                    
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.name;
                    if (index === 0) option.selected = true;
                    modelSelect.appendChild(option);
                });
                
                // Return the first model ID to load
                return data.models.length > 0 ? data.models[0].id : null;
            } catch (error) {
                console.error('Error loading models config:', error);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
                return null;
            }
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); // White background

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.01,
                1000
            );
            camera.position.set(2, 1.5, 2);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(5, 10, 7);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
            scene.add(hemisphereLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 0.5;
            controls.maxDistance = 50;
            controls.target.set(0, 0, 0);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Model selector change
            modelSelect.addEventListener('change', (e) => {
                loadModel(e.target.value);
            });

            // Camera toggle change
            cameraToggle.addEventListener('change', (e) => {
                toggleCameraVisibility(e.target.checked);
            });

            // Start animation loop
            animate();
            
            // Load models config and then load the first model
            loadModelsConfig().then(firstModelId => {
                if (firstModelId) {
                    loadModel(firstModelId);
                }
            });
        }

        async function loadModel(modelKey) {
            const modelData = MODELS[modelKey];
            if (!modelData) return;

            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            
            // Update photos gallery
            populatePhotosGallery(modelData.photos);
            
            // Update location display
            updateLocationDisplay(modelData.location, modelData.mapsLink);

            // Remove current model if exists
            if (currentModel) {
                scene.remove(currentModel);
                currentModel.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            
            // Remove points object if exists
            if (pointsObject) {
                scene.remove(pointsObject);
                if (pointsObject.geometry) pointsObject.geometry.dispose();
                if (pointsObject.material) pointsObject.material.dispose();
                pointsObject = null;
            }

            // Verify the file exists and is accessible before loading
            try {
                const response = await fetch(modelData.path, { method: 'HEAD' });
                if (!response.ok) {
                    throw new Error(`File not found: ${modelData.path} (Status: ${response.status})`);
                }
                const contentType = response.headers.get('content-type');
                if (contentType && !contentType.includes('model/gltf') && !contentType.includes('application/octet-stream')) {
                    console.warn(`Unexpected content type: ${contentType} for ${modelData.path}`);
                }
            } catch (fetchError) {
                console.error('Error checking model file:', fetchError);
                // Continue anyway - the GLTFLoader will handle the error
            }

            const loader = new GLTFLoader();
            console.log('Loading model from path:', modelData.path);
            loader.load(
                modelData.path,
                (gltf) => {
                    currentModel = gltf.scene;

                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Center the model
                    currentModel.position.sub(center);
                    
                    // Scale to fit nicely in view
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    currentModel.scale.setScalar(scale);

                    scene.add(currentModel);

                    // Identify camera frustum objects
                    // Camera frustums in trimesh GLB exports are typically Mesh objects
                    // that have relatively few vertices (camera wireframes) vs the main point cloud
                    cameraObjects = [];
                    mainPointCloud = null;
                    let maxVertices = 0;
                    
                    // First pass: find the main point cloud (largest vertex count)
                    currentModel.traverse((child) => {
                        if (child.geometry?.attributes?.position) {
                            const count = child.geometry.attributes.position.count;
                            if (count > maxVertices) {
                                maxVertices = count;
                                mainPointCloud = child;
                            }
                        }
                    });
                    
                    // Convert main point cloud mesh to Points for size control
                    pointsObject = null;
                    if (mainPointCloud) {
                        console.log('Main point cloud type:', mainPointCloud.type, 'isMesh:', mainPointCloud.isMesh, 'isPoints:', mainPointCloud.isPoints);
                        
                        if (mainPointCloud.isMesh) {
                            const points = convertMeshToPoints(mainPointCloud);
                            if (points) {
                                // Add points directly to the scene
                                scene.add(points);
                                // Hide the original mesh completely
                                mainPointCloud.visible = false;
                                // Store reference to the points object
                                pointsObject = points;
                                // Expose for debugging
                                window.pointsObject = points;
                                window.mainPointCloud = mainPointCloud;
                                console.log('Created Points object with', points.geometry.attributes.position.count, 'points');
                            }
                        } else if (mainPointCloud.isPoints) {
                            // Already a Points object, just store reference
                            pointsObject = mainPointCloud;
                            window.pointsObject = mainPointCloud;
                            console.log('Model already has Points object with', mainPointCloud.geometry.attributes.position.count, 'points');
                        }
                    }
                    
                    // Second pass: everything that's NOT the main point cloud is likely camera-related
                    currentModel.traverse((child) => {
                        if (child !== mainPointCloud && 
                            (child.isMesh || child.isLine || child.isLineSegments || child.isPoints) &&
                            child.geometry?.attributes?.position) {
                            cameraObjects.push(child);
                        }
                    });

                    // Apply current toggle state
                    toggleCameraVisibility(cameraToggle.checked);

                    // Reset camera position
                    camera.position.set(2, 1.5, 2);
                    controls.target.set(0, 0, 0);
                    controls.update();

                    // Hide loading indicator
                    loadingIndicator.style.display = 'none';
                },
                (progress) => {
                    // Progress callback (optional)
                },
                (error) => {
                    console.error('Error loading model:', error);
                    console.error('Failed path:', modelData.path);
                    console.error('Error details:', {
                        message: error.message,
                        response: error.response,
                        status: error.status
                    });
                    
                    // Try to fetch the file directly to see what we're getting
                    fetch(modelData.path)
                        .then(response => {
                            console.log('Fetch response status:', response.status);
                            console.log('Fetch response headers:', Object.fromEntries(response.headers.entries()));
                            return response.text();
                        })
                        .then(text => {
                            console.log('Response preview (first 200 chars):', text.substring(0, 200));
                        })
                        .catch(fetchError => {
                            console.error('Fetch error:', fetchError);
                        });
                    
                    loadingIndicator.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Error loading model</span>';
                }
            );
        }

        function toggleCameraVisibility(visible) {
            cameraObjects.forEach((obj) => {
                obj.visible = visible;
            });
        }

        function updateLocationDisplay(location, mapsLink) {
            if (!locationDisplay) return;
            
            if (location && mapsLink) {
                locationDisplay.innerHTML = `<a href="${mapsLink}" target="_blank" rel="noopener noreferrer" style="color: var(--color-main); text-decoration: none;">üìç ${location}</a>`;
            } else if (location) {
                locationDisplay.innerHTML = `üìç ${location}`;
            } else {
                locationDisplay.innerHTML = '';
            }
        }

        function convertMeshToPoints(mesh) {
            // Convert a mesh to a Points object for better point size control
            if (!mesh.geometry) return null;
            
            const geometry = mesh.geometry.clone();
            
            // Apply the mesh's world matrix to the geometry so points are in world space
            mesh.updateWorldMatrix(true, false);
            geometry.applyMatrix4(mesh.matrixWorld);
            
            // Create point material with vertex colors if available
            const material = new THREE.PointsMaterial({
                size: 0.01,
                vertexColors: geometry.attributes.color ? true : false,
                sizeAttenuation: true
            });
            
            // If original material has a color and no vertex colors, use it
            if (!geometry.attributes.color && mesh.material && mesh.material.color) {
                material.color = mesh.material.color;
            }
            
            const points = new THREE.Points(geometry, material);
            // Points are now in world space, so no need to copy transforms
            
            return points;
        }

        function populatePhotosGallery(photos) {
            photosGallery.innerHTML = '';
            
            if (!photos || photos.length === 0) {
                photosGallery.innerHTML = '<p class="photos-empty">No source photos available for this model</p>';
                return;
            }
            
            photos.forEach((photoPath, index) => {
                const imgContainer = document.createElement('div');
                imgContainer.className = 'photo-item';
                
                const img = document.createElement('img');
                // photoPath is already the full path (with base path included)
                img.src = photoPath;
                img.alt = `Source photo ${index + 1}`;
                img.loading = 'lazy'; // Lazy load for performance
                
                // Add click handler to open full size
                img.addEventListener('click', () => {
                    window.open(img.src, '_blank');
                });
                
                imgContainer.appendChild(img);
                photosGallery.appendChild(imgContainer);
            });
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize when DOM is ready
        init();

        // Load header and footer
        window.onload = function() {
            loadHeader();
            loadFooter();
        };
    </script>
</body>
</html>
